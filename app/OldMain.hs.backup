module Main where

import qualified Data.Vector as V
import Linear hiding (rotate)
import System.IO.Unsafe

import Generate
import Generate.Colour.SimplePalette
import Generate.Patterns.Bands
import Generate.Patterns.NoiseWalker
import Generate.Patterns.RecursiveSplit
import Generate.Patterns.Sampling
import Generate.Patterns.Water
import Generate.Raster.Sand

import PetalStroke

mkPalette :: Generate SimplePalette
mkPalette = randElem $ V.fromList [jhoto, castle, metroid, gurken, mondrian]

background :: SimplePalette -> Generate (Render ())
background palette = do
  World {..} <- asks world
  return $ do
    setColour $ bgColour palette
    rectangle 0 0 width height
    fill

data BrushStroke = BrushStroke
  { palette :: SimplePalette
  , squigglyPathCfg :: SquigglyPathCfg
  , thickness :: Int
  , startSpread :: RVar Double
  }

renderStroke :: BrushStroke -> Generate (Render ())
renderStroke (BrushStroke palette cfg thickness spreadM) = do
  let startPoint = do
        theta <- sampleRVar $ uniform 0 $ 2 * pi
        spread <- sampleRVar spreadM
        return $ circumPoint (start cfg) theta spread
  paths <-
    sequence $
    map
      (const $ startPoint >>= \start' -> squigglyPath cfg {start = start'})
      [0 .. thickness]
  colours <- sequence $ map (const $ fgColour palette) paths
  return $ do
    setLineWidth 0.08
    foldr1 (>>) $
      map
        (\(p, c) -> do
           setColour c
           draw p
           stroke) $
      zip paths colours

bandBox :: SimplePalette -> Rect -> Generate (Render ())
bandBox palette box = do
  c <- fgColour palette
  let bounds = intoBounds $ UniformBands 3
  let box' = scaleFromCenter 0.7 box
  let bands = [box'] -- bandsOnAxis X bounds box'
  scales <- sequence $ map (const $ sampleRVar $ normal 1 0.3) bands
  let bands' = map (uncurry scaleFromCenter) $ zip scales bands
  let toLine rect =
        let ps = points rect
         in mkLine $ V.snoc ps (V.head ps)
  let polies = map (fromJust . toLine) bands'
  let splotches = map (\p -> mkSplotch p c) polies
  wigglePower <- sampleRVar $ normal 0 4 >>= return . (+ 1) . abs
  let wiggler =
        Wiggler $ \p@(V2 x y) -> do
          n <- noiseSample $ V3 x y 1.2
          let w = radialWiggler $ 0.5 * n * wigglePower
          wiggle w p
  splotches' <- sequence $ map (waterColour wiggler def) splotches
  return $ foldr (>>) (pure ()) $ map ((>> fill) . draw) $ concat splotches'

sandCfg = SandCfg {attempts = 500, mkElement = \p -> pure $ Circle p 0.2}

dots :: Generate [Circle]
dots = do
  frame <- fullFrame
  count :: Int <- sampleRVar $ uniform 10 3000
  spawnPoints <- mapM (const $ spatialSample frame) [0 .. count]
  return $ map (\c -> Circle c 1) spawnPoints

stepDots :: V.Vector Rect -> V.Vector Circle -> Generate (V.Vector Circle)
stepDots rs cs = V.mapM (stepDot rs) cs >>= return . (V.mapMaybe (id))

stepDot :: V.Vector Rect -> Circle -> Generate (Maybe Circle)
stepDot rs (Circle c@(V2 x y) r) = do
  n <- noiseSample $ V3 x y r
  let c' = circumPoint c (n * 2 * pi) r
  if V.any (\rect -> distanceToRect rect c' < 0) rs
    then return Nothing
    else return $ Just $ Circle c' r

data TraceDot = TraceDot
  { palette :: SimplePalette
  , traceDot :: Circle
  }

instance Element TraceDot where
  realize (TraceDot palette (Circle c r)) =
    renderStroke $ BrushStroke palette def 5 (normal 0 5)

scene :: SimplePalette -> Generate (Render ())
scene palette = do
  root <- centerPoint
  frame <- fullFrame
  let box = scaleFromCenter 0.8 frame
  colour <- fgColour palette
  let predicate :: Generate Bool =
        sampleRVar (uniform (negate 1) 1) >>= \(v :: Double) -> return $ v > 0
  boxes <- recursiveSplit def frame -- >>= fairFilter predicate
  let boxes' = map (scaleFromCenter 0.8) boxes
  bandBoxes <- mapM (bandBox palette) boxes'
  boxDraws <-
    sequence $
    map
      (\b -> do
         colour <- fgColour palette
         return $ do
           setColour (colour, 0.5 :: Double)
           b
           fill)
      bandBoxes
  return $ do
    setColour colour
    setLineWidth 1
    foldr (>>) (pure ()) boxDraws

main :: IO ()
main = do
  putStrLn $ show $ intoBounds $ UniformBands 3
  runInvocation $ do
    palette <- mkPalette
    bg <- background palette
    fg1 <- scene palette
    fg2 <- scene palette
    spawnPoints <- dots
    strokes <-
      mapM
        (\(Circle p _) ->
           renderStroke $
           BrushStroke
             { palette = palette
             , squigglyPathCfg =
                 SquigglyPathCfg
                   NoiseWalkerCfg
                     {scale = uniform 1000 2200, step = uniform 0.1 0.4}
                   20000
                   p
             , thickness = 700
             , startSpread = normal 0 2
             }) $
      take 1 spawnPoints
    return $ do
      bg
      foldr1 (>>) strokes
