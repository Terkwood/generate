module Main where

import qualified Data.Vector as V
import Linear hiding (rotate)
import System.IO.Unsafe

import Generate
import qualified Generate.Algo.QuadTree as Q
import qualified Generate.Algo.Vec as V
import Generate.Colour.SimplePalette
import Generate.Colour.THColours
import Generate.Geom.Frame
import Generate.Patterns.Grid
import Generate.Patterns.Maze
import Generate.Patterns.Sampling
import Generate.Patterns.Water
import Petal

ramp :: Int -> [Double]
ramp total = map valueOf [0 .. total]
  where
    valueOf i = (fromIntegral i) / (fromIntegral total)

mkPalette :: Generate SimplePalette
mkPalette =
  randElem $
  V.fromList
    [ jhoto
    , metroid
    , mkSimplePalette "EFC271" ["3E8A79", "E9A931", "F03E4D", "CC3433"]
    ]

mkNoiseWiggler :: Double -> Double -> Double -> Wiggler
mkNoiseWiggler z strength smoothness =
  Wiggler $ \p@(V2 x y) -> do
    let scale = 1 / smoothness
    let fixSamplePoint = fmap (scale *)
    theta <-
      (noiseSample $ fixSamplePoint $ V3 x y z) >>= return . (\x -> x * 2 * pi)
    r <-
      (noiseSample $ fixSamplePoint $ V3 x y (negate z)) >>=
      return . (* strength)
    return $ circumPoint p theta r

data Blob = Blob
  { line :: [Generate (V2 Double)]
  , colour :: (RGB Double, Double)
  }

mkBlob :: Sample s => s -> Double -> Double -> THColours -> Generate Blob
mkBlob space baseSize smoothness palette = do
  World {..} <- asks world
  center <- spatialSample space
  r <- (sampleRVar $ normal 0 (baseSize / 2)) >>= return . (+ baseSize)
  let circle = Circle center r
  z <- sampleRVar $ uniform 0 1000
  deformity <- (sampleRVar $ normal (r / 2) (r / 8)) >>= return . abs
  let wiggler = mkNoiseWiggler z deformity smoothness
  let mkCircumPoint theta = do
        let p = circumPoint center theta r
        wiggle wiggler p
  colour <- assignTHColour palette center
  return $
    Blob
      { line = map mkCircumPoint $ map (\x -> x * 2 * pi) $ ramp $ floor width
      , colour = (colour, 1.0)
      }

instance Wiggle Blob where
  wiggle (Wiggler f) blob@(Blob line _) = do
    line_ <- sequence line
    line' <- sequence $ map f line_
    return $ blob {line = map pure line'}
    -- TODO: Make colored class to get these things for free

instance Translucent Blob where
  setOpacity opacity blob@(Blob _ (c, o)) = blob {colour = (c, opacity)}

instance Subdivisible Blob where
  subdivide blob@(Blob line _) =
    let pairs :: [(Generate (V2 Double), Generate (V2 Double))] =
          zip line $ tail line
     in blob {line = concat $ map (\(a, b) -> [a, connect a b, b]) $ pairs}

connect :: Generate (V2 Double) -> Generate (V2 Double) -> Generate (V2 Double)
connect p1 p2 = do
  a <- p1
  b <- p2
  return $ midpoint a b

mkBlobPool :: Double -> THColours -> Generate [Blob]
mkBlobPool smoothness palette = do
  baseSize <- sampleRVar $ uniform 50 100
  frameScale <- sampleRVar $ uniform 0.3 0.7
  frameThickness <- sampleRVar $ uniform 0.1 0.3
  border <- fullFrame >>= return . (scaleFromCenter frameScale)
  let frame = mkFrame border frameThickness
  blobCount <- sampleRVar $ uniform 5 40
  sequence $ take blobCount $ repeat $ mkBlob frame baseSize smoothness palette

instance Element Blob where
  realize (Blob line coloura@(colour, a)) = do
    line_ <- sequence line
    frame <- fullFrame
    let count = 1000
    textureCircles <-
      sequence $
      take count $
      repeat $ do
        c <- spatialSample frame
        return $ Circle c 1
    realCenter <- centerPoint
    let (h, s, v) = hsvView colour
    textureColours <-
      sequence $
      take count $
      repeat $ do
        satDiff <- sampleRVar $ normal 0 0.8
        valueDiff <- sampleRVar $ normal 0 0.8
        return $ hsv h (s * (1.0 + satDiff)) (v * (1.0 + valueDiff))
    let blobDraw = do
          setColour coloura
          draw line_
          closePath
          fill
    let textureDraw = do
          foldr1 (>>) $
            map
              (\(col, cir) -> setColour (col, 0.5 :: Double) >> draw cir >> fill) $
            zip textureColours textureCircles
    let textureMask = alphaMatte blobDraw textureDraw
    return $ do
      blobDraw
      --operator <- getOperator
      --setOperator OperatorOverlay
      textureMask
      --setOperator operator

background :: SimplePalette -> Generate (Render ())
background palette = do
  World {..} <- asks world
  return $ do
    setColour $ bgColour palette
    rectangle 0 0 width height
    fill

scene :: THColours -> Generate (Render ())
scene basePalette = do
  World {..} <- asks world
  frame <- fullFrame
  smoothness <- sampleRVar $ uniform 10 200
  waterSmoothness <- sampleRVar $ uniform 10 40
  blobs <- mkBlobPool smoothness basePalette
  wigglerVariance <- sampleRVar $ uniform 5 20
  let mkWiggler _ = do
        z <- sampleRVar $ uniform 0 1000
        deformity <- sampleRVar $ normal 0 wigglerVariance >>= return . abs
        return $ mkNoiseWiggler z deformity waterSmoothness
  let mkSplotch blob i = do
        opacity <- sampleRVar $ uniform 0.03 0.04
        layers <- sampleRVar $ uniform 30 100
        flatWaterColour opacity layers mkWiggler blob
  blobSplotches :: [[Blob]] <-
    sequence $ map (uncurry mkSplotch) $ zip blobs [0 ..]
  realizeAll $ concat blobSplotches

main :: IO ()
main = do
  runInvocation $ do
    palette <- mkPalette
    fgPalette <- mkTHColours palette
    bg <- background palette
    fg <- scene fgPalette
    return $ bg >> fg
